//
//  MealLogViewModel.swift
//  Zipack
//
//  Created by Tutu on 7/12/25.
//
import Foundation
import FirebaseFirestore
import Combine

class MealLogViewModel: ObservableObject {
    @Published var loggedMeals: [LoggedMeal] = []
    @Published var dailyConsumedCalories: Int = 0
    @Published var dailyConsumedProtein: Int = 0
    @Published var dailyConsumedCarbs: Int = 0
    @Published var dailyConsumedFat: Int = 0
    @Published var isLoading: Bool = false
    @Published var errorMessage: String? // For general errors/messages

    private var db: Firestore { FirebaseManager.shared.db }
    private var userId: String? { FirebaseManager.shared.userId }
    private var cancellables = Set<AnyCancellable>()

    init() {
        setupMealLogListener()
    }

    private func setupMealLogListener() {
        FirebaseManager.shared.$isAuthReady
            .filter { $0 } // Wait until Firebase is ready
            .compactMap { _ in FirebaseManager.shared.userId }
            .sink { [weak self] uid in
                guard let self = self else { return }
                // Ensure all UI-related updates happen on the main thread
                DispatchQueue.main.async {
                    self.isLoading = true
                }
                self.db.collection("artifacts/\(NATIVE_APP_ID)/users/\(uid)/loggedMeals")
                    .addSnapshotListener { querySnapshot, error in
                        // Ensure all UI-related updates happen on the main thread
                        DispatchQueue.main.async {
                            self.isLoading = false
                            if let error = error {
                                self.errorMessage = "Error fetching logged meals: \(error.localizedDescription)"
                                print(self.errorMessage!)
                                return
                            }
                            self.loggedMeals = querySnapshot?.documents.compactMap { document in
                                try? document.data(as: LoggedMeal.self)
                            } ?? []
                            self.calculateDailyTotals() // Recalculate totals whenever meals change
                        }
                    }
            }
            .store(in: &cancellables)
    }

    // Calculates the sum of calories and macros for meals logged today
    func calculateDailyTotals() {
        var totalCalories = 0
        var totalProtein = 0
        var totalCarbs = 0
        var totalFat = 0

        let today = Calendar.current.startOfDay(for: Date()) // Get the start of the current day

        loggedMeals.forEach { meal in
            // Check if the meal's timestamp falls within the current day
            if Calendar.current.isDate(meal.timestamp.dateValue(), inSameDayAs: today) {
                totalCalories += meal.calories
                totalProtein += meal.protein
                totalCarbs += meal.carbs
                totalFat += meal.fat
            }
        }

        // Update published properties, triggering UI updates
        // Ensure UI updates on main thread
        DispatchQueue.main.async {
            self.dailyConsumedCalories = totalCalories
            self.dailyConsumedProtein = totalProtein
            self.dailyConsumedCarbs = totalCarbs
            self.dailyConsumedFat = totalFat
        }
    }
    
    // NEW: Check if a recipe with the given ID has already been logged today
    func isRecipeLoggedToday(recipeId: String) -> Bool {
        let today = Calendar.current.startOfDay(for: Date())
        return loggedMeals.contains { meal in
            Calendar.current.isDate(meal.timestamp.dateValue(), inSameDayAs: today) && meal.recipeId == recipeId
        }
    }

    // Logs a meal generated by the AI
    func logMeal(recipe: GeneratedRecipe) {
        guard let userId = userId else {
            errorMessage = "User not authenticated."
            return
        }
        
        // NEW: Prevent multiple entries for the same generated recipe on the same day
        if isRecipeLoggedToday(recipeId: recipe.id) {
            DispatchQueue.main.async {
                self.errorMessage = "This recipe has already been logged today!"
            }
            return
        }

        // Ensure UI updates on main thread
        DispatchQueue.main.async {
            self.isLoading = true
            self.errorMessage = nil // Clear previous error
        }
        let newLog = LoggedMeal(
            recipeName: recipe.recipeName,
            calories: recipe.nutritionalInfo?.calories ?? 0,
            protein: recipe.nutritionalInfo?.proteinGrams ?? 0,
            carbs: recipe.nutritionalInfo?.carbsGrams ?? 0,
            fat: recipe.nutritionalInfo?.fatGrams ?? 0,
            timestamp: Timestamp(date: Date()),
            source: "generated",
            recipeId: recipe.id // Store the generated recipe's ID
        )
        do {
            _ = try db.collection("artifacts/\(NATIVE_APP_ID)/users/\(userId)/loggedMeals")
                .addDocument(from: newLog) { error in
                    // Ensure all UI-related updates happen on the main thread
                    DispatchQueue.main.async {
                        self.isLoading = false
                        if let error = error {
                            self.errorMessage = "Error logging meal: \(error.localizedDescription)"
                        } else {
                            self.errorMessage = "Meal '\(recipe.recipeName)' logged successfully!" // Success message
                            print("Meal logged successfully.")
                        }
                    }
                }
        } catch {
            // Ensure UI updates on main thread
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Error encoding logged meal: \(error.localizedDescription)"
            }
        }
    }

    // Logs a meal manually entered by the user
    func quickAddMeal(name: String, calories: Int, protein: Int, carbs: Int, fat: Int) {
        guard let userId = userId else {
            errorMessage = "User not authenticated."
            return
        }
        // Ensure UI updates on main thread
        DispatchQueue.main.async {
            self.isLoading = true
            self.errorMessage = nil // Clear previous error
        }
        let newLog = LoggedMeal(
            recipeName: name,
            calories: calories,
            protein: protein,
            carbs: carbs,
            fat: fat,
            timestamp: Timestamp(date: Date()),
            source: "manual",
            recipeId: nil // No generated recipe ID for manual entries
        )
        do {
            _ = try db.collection("artifacts/\(NATIVE_APP_ID)/users/\(userId)/loggedMeals")
                .addDocument(from: newLog) { error in
                    // Ensure all UI-related updates happen on the main thread
                    DispatchQueue.main.async {
                        self.isLoading = false
                        if let error = error {
                            self.errorMessage = "Error quick adding meal: \(error.localizedDescription)"
                        } else {
                            self.errorMessage = "Manual meal '\(name)' logged successfully!" // Success message
                            print("Manual meal logged successfully.")
                        }
                    }
                }
        } catch {
            // Ensure UI updates on main thread
            DispatchQueue.main.async {
                self.isLoading = false
                self.errorMessage = "Error encoding manual meal: \(error.localizedDescription)"
            }
        }
    }

    // Clears all meals logged for the current day
    func clearDailyLog() {
        guard let userId = userId else {
            errorMessage = "User not authenticated."
            return
        }
        // Ensure UI updates on main thread
        DispatchQueue.main.async {
            self.isLoading = true
            self.errorMessage = nil // Clear previous error
        }

        let today = Calendar.current.startOfDay(for: Date())
        let batch = db.batch() // Use a batch write for efficiency when deleting multiple documents

        // Filter meals that were logged today
        loggedMeals.filter { Calendar.current.isDate( $0.timestamp.dateValue(), inSameDayAs: today) }
            .forEach { meal in
                if let id = meal.id {
                    let docRef = db.collection("artifacts/\(NATIVE_APP_ID)/users/\(userId)/loggedMeals").document(id)
                    batch.deleteDocument(docRef) // Add delete operation to the batch
                }
            }

        // Commit the batch write
        batch.commit { error in
            // Ensure all UI-related updates happen on the main thread
            DispatchQueue.main.async {
                self.isLoading = false
                if let error = error {
                    self.errorMessage = "Error clearing daily log: \(error.localizedDescription)"
                } else {
                    self.errorMessage = "Today's logged meals cleared!" // Success message
                    print("Daily log cleared successfully.")
                }
            }
        }
    }
}
